#include "config.h"
#include "fakeFMIDecls.h"

#include <stdio.h>
#include <stdlib.h>

fmiComponent *modelInstances[MaxFMUInstances]; // start of with an empty array of components
int conInstanceCount = 0;

// Variables and constants
fmiValueReference b_environImpl_ = 0;
fmiValueReference tmp_environImpl_ = 0;
fmiBoolean b[booleanArraySize];
fmiInteger i[integerArraySize];


//## <addToHeader>
fmiComponent *fmiInstantiateSlave(fmiString instanceName, fmiString fmuGUID,
		fmiString fmuResourceLocation, const fmiCallbackFunctions* functions,
		fmiBoolean visible, fmiBoolean loggingOn) {
	// create a fmiComponent and allocate storage space
	fmiComponent *c = malloc(sizeof(*c));
	if (!(conInstanceCount <= (MaxFMUInstances - 1))) {
		c->validInstance = fmiFalse;
		return c;
	} else {
		c->validInstance = fmiTrue;
		// set the name etc
		c->fmuInstanceName = instanceName;
		c->fmuGUID = fmuGUID;
		//add instance to collection;
		modelInstances[conInstanceCount] = c;
		conInstanceCount = conInstanceCount + 1;
		return c;
	}
}

//## <addToHeader>
fmiStatus *fmiInitializeSlave(fmiComponent c,
		fmiReal relativeTolerance, fmiReal tStart,
		fmiBoolean stopTimeDefined, fmiReal tStop) {

// Generated By InitialisationsListGenerator 
		 c -> i [b_environImpl_] = 99 ; 
		 c -> b [tmp_environImpl_] = fmiTrue ; 


		return fmiOK;

}

// Subroutines Generated from Events


fmiStatus getInteger(fmiComponent c, const fmiValueReference vr[], size_t nvr, fmiInteger value[])
{
// Translated code
// for our initial work we return all values in the array
for(int idx = 0; idx < nvr; idx = idx + 1){
value[ vr[idx] ] = c -> i [ vr[idx] ];
}
return fmiOK;
}

fmiStatus fmiDoStep(fmiComponent c, fmiReal currentCommunicationPoint, fmiReal communicationStepSize, fmiBoolean noSetFMUStatePriorToCurrentPoint)
{
// Translated code
 c -> i [ b_environImpl_ ] = ( c -> i [ b_environImpl_ ] + 1 ); 
 printf (" b : % i \ n ", c -> i [ b_environImpl_ ] ); 
return fmiOK;
}


