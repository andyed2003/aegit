#include "config.h"
#include "fakeFMIDecls.h"

#include <stdio.h>
#include <stdlib.h>

fmiComponent *modelInstances[MaxFMUInstances]; // start of with an empty array of components
int conInstanceCount = 0;

// Variables and constants
fmiValueReference a_controllerImpl_ = 0;
fmiValueReference used_a_controllerImpl_ = 1;
fmiInteger i[integerArraySize];


//## <addToHeader>
fmiComponent *fmiInstantiateSlave(fmiString instanceName, fmiString fmuGUID,
		fmiString fmuResourceLocation, const fmiCallbackFunctions* functions,
		fmiBoolean visible, fmiBoolean loggingOn) {
	// create a fmiComponent and allocate storage space
	fmiComponent *c = malloc(sizeof(*c));
	if (!(conInstanceCount <= (MaxFMUInstances - 1))) {
		c->validInstance = fmiFalse;
		return c;
	} else {
		c->validInstance = fmiTrue;
		// set the name etc
		c->fmuInstanceName = instanceName;
		c->fmuGUID = fmuGUID;
		//add instance to collection;
		modelInstances[conInstanceCount] = c;
		conInstanceCount = conInstanceCount + 1;
		return c;
	}
}

//## <addToHeader>
fmiStatus *fmiInitializeSlave(fmiComponent c,
		fmiReal relativeTolerance, fmiReal tStart,
		fmiBoolean stopTimeDefined, fmiReal tStop) {

// Generated By InitialisationsListGenerator 
		 c -> i [a_controllerImpl_] = 0 ; 
		 c -> i [used_a_controllerImpl_] = 0 ; 


		return fmiOK;

}

// Subroutines Generated from Events


fmiStatus setInteger(fmiComponent c, const fmiValueReference vr[], size_t nvr, fmiInteger value[])
{
// Translated code
// for our initial work we set all values in the array
for(int idx = 0; idx < nvr; idx = idx + 1){
c -> i [ vr[idx] ] = value[ vr[idx] ];
}
return fmiOK;
}

fmiStatus fmiDoStep(fmiComponent c, fmiReal currentCommunicationPoint, fmiReal communicationStepSize, fmiBoolean noSetFMUStatePriorToCurrentPoint)
{
// Translated code
 c -> i [used_a_controllerImpl_] = (( c -> i [ a_controllerImpl_ ] ) / 2 ); 
 printf (" used_a : % i \ n ", c -> i [used_a_controllerImpl_] ); 
return fmiOK;
}


